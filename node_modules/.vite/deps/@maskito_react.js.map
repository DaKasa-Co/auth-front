{
  "version": 3,
  "sources": ["../../@maskito/core/index.esm.js", "../../@maskito/react/index.esm.js"],
  "sourcesContent": ["const MASKITO_DEFAULT_ELEMENT_PREDICATE = e => e.querySelector('input,textarea') || e;\n\nconst MASKITO_DEFAULT_OPTIONS = {\n  mask: /^.*$/,\n  preprocessors: [],\n  postprocessors: [],\n  plugins: [],\n  overwriteMode: 'shift'\n};\n\nclass MaskHistory {\n  constructor() {\n    this.now = null;\n    this.past = [];\n    this.future = [];\n  }\n\n  undo() {\n    const state = this.past.pop();\n\n    if (state && this.now) {\n      this.future.push(this.now);\n      this.updateElement(state, 'historyUndo');\n    }\n  }\n\n  redo() {\n    const state = this.future.pop();\n\n    if (state && this.now) {\n      this.past.push(this.now);\n      this.updateElement(state, 'historyRedo');\n    }\n  }\n\n  updateHistory(state) {\n    if (!this.now) {\n      this.now = state;\n      return;\n    }\n\n    const isValueChanged = this.now.value !== state.value;\n    const isSelectionChanged = this.now.selection.some((item, index) => item !== state.selection[index]);\n\n    if (!isValueChanged && !isSelectionChanged) {\n      return;\n    }\n\n    if (isValueChanged) {\n      this.past.push(this.now);\n      this.future = [];\n    }\n\n    this.now = state;\n  }\n\n  updateElement(state, inputType) {\n    this.now = state;\n    this.updateElementState(state, {\n      inputType,\n      data: null\n    });\n  }\n\n}\n\nfunction areElementValuesEqual(sampleState, ...states) {\n  return states.every(({\n    value\n  }) => value === sampleState.value);\n}\nfunction areElementStatesEqual(sampleState, ...states) {\n  return states.every(({\n    value,\n    selection\n  }) => value === sampleState.value && selection[0] === sampleState.selection[0] && selection[1] === sampleState.selection[1]);\n}\n\nfunction applyOverwriteMode({\n  value,\n  selection\n}, newCharacters, mode) {\n  const [from, to] = selection;\n  const computedMode = typeof mode === 'function' ? mode({\n    value,\n    selection\n  }) : mode;\n  return {\n    value,\n    selection: computedMode === 'replace' ? [from, from + newCharacters.length] : [from, to]\n  };\n}\n\nfunction isFixedCharacter(char) {\n  return typeof char === 'string';\n}\n\nfunction getLeadingFixedCharacters(mask, validatedValuePart, newCharacter, initialElementState) {\n  let leadingFixedCharacters = '';\n\n  for (let i = validatedValuePart.length; i < mask.length; i++) {\n    const charConstraint = mask[i];\n    const isInitiallyExisted = (initialElementState === null || initialElementState === void 0 ? void 0 : initialElementState.value[i]) === charConstraint;\n\n    if (!isFixedCharacter(charConstraint) || charConstraint === newCharacter && !isInitiallyExisted) {\n      return leadingFixedCharacters;\n    }\n\n    leadingFixedCharacters += charConstraint;\n  }\n\n  return leadingFixedCharacters;\n}\n\nfunction validateValueWithMask(value, maskExpression) {\n  if (Array.isArray(maskExpression)) {\n    return value.length === maskExpression.length && Array.from(value).every((char, i) => {\n      const charConstraint = maskExpression[i];\n      return isFixedCharacter(charConstraint) ? char === charConstraint : char.match(charConstraint);\n    });\n  }\n\n  return maskExpression.test(value);\n}\n\nfunction guessValidValueByPattern(elementState, mask, initialElementState) {\n  let maskedFrom = null;\n  let maskedTo = null;\n  const maskedValue = Array.from(elementState.value).reduce((validatedCharacters, char, charIndex) => {\n    const leadingCharacters = getLeadingFixedCharacters(mask, validatedCharacters, char, initialElementState);\n    const newValidatedChars = validatedCharacters + leadingCharacters;\n    const charConstraint = mask[newValidatedChars.length];\n\n    if (isFixedCharacter(charConstraint)) {\n      return newValidatedChars + charConstraint;\n    }\n\n    if (!char.match(charConstraint)) {\n      return newValidatedChars;\n    }\n\n    if (maskedFrom === null && charIndex >= elementState.selection[0]) {\n      maskedFrom = newValidatedChars.length;\n    }\n\n    if (maskedTo === null && charIndex >= elementState.selection[1]) {\n      maskedTo = newValidatedChars.length;\n    }\n\n    return newValidatedChars + char;\n  }, '');\n  const trailingFixedCharacters = getLeadingFixedCharacters(mask, maskedValue, '', initialElementState);\n  return {\n    value: validateValueWithMask(maskedValue + trailingFixedCharacters, mask) ? maskedValue + trailingFixedCharacters : maskedValue,\n    selection: [maskedFrom !== null && maskedFrom !== void 0 ? maskedFrom : maskedValue.length, maskedTo !== null && maskedTo !== void 0 ? maskedTo : maskedValue.length]\n  };\n}\n\nfunction guessValidValueByRegExp({\n  value,\n  selection\n}, maskRegExp) {\n  const [from, to] = selection;\n  let newFrom = from;\n  let newTo = to;\n  const validatedValue = Array.from(value).reduce((validatedValuePart, char, i) => {\n    const newPossibleValue = validatedValuePart + char;\n\n    if (from === i) {\n      newFrom = validatedValuePart.length;\n    }\n\n    if (to === i) {\n      newTo = validatedValuePart.length;\n    }\n\n    return newPossibleValue.match(maskRegExp) ? newPossibleValue : validatedValuePart;\n  }, '');\n  return {\n    value: validatedValue,\n    selection: [newFrom, newTo]\n  };\n}\n\nfunction calibrateValueByMask(elementState, mask, initialElementState = null) {\n  if (validateValueWithMask(elementState.value, mask)) {\n    return elementState;\n  }\n\n  const {\n    value,\n    selection\n  } = Array.isArray(mask) ? guessValidValueByPattern(elementState, mask, initialElementState) : guessValidValueByRegExp(elementState, mask);\n  return {\n    selection,\n    value: Array.isArray(mask) ? value.slice(0, mask.length) : value\n  };\n}\n\nfunction removeFixedMaskCharacters(initialElementState, mask) {\n  if (!Array.isArray(mask)) {\n    return initialElementState;\n  }\n\n  const [from, to] = initialElementState.selection;\n  const selection = [];\n  const unmaskedValue = Array.from(initialElementState.value).reduce((rawValue, char, i) => {\n    const charConstraint = mask[i];\n\n    if (i === from) {\n      selection.push(rawValue.length);\n    }\n\n    if (i === to) {\n      selection.push(rawValue.length);\n    }\n\n    return isFixedCharacter(charConstraint) && charConstraint === char ? rawValue : rawValue + char;\n  }, '');\n\n  if (selection.length < 2) {\n    selection.push(...new Array(2 - selection.length).fill(unmaskedValue.length));\n  }\n\n  return {\n    value: unmaskedValue,\n    selection: [selection[0], selection[1]]\n  };\n}\n\nclass MaskModel {\n  constructor(initialElementState, maskOptions) {\n    this.initialElementState = initialElementState;\n    this.maskOptions = maskOptions;\n    this.value = '';\n    this.selection = [0, 0];\n    const {\n      value,\n      selection\n    } = calibrateValueByMask(initialElementState, this.getMaskExpression(initialElementState));\n    this.value = value;\n    this.selection = selection;\n  }\n\n  addCharacters([from, to], newCharacters) {\n    const {\n      value\n    } = this;\n    const maskExpression = this.getMaskExpression({\n      value: value.slice(0, from) + newCharacters + value.slice(to),\n      selection: [from + newCharacters.length, from + newCharacters.length]\n    });\n    const initialElementState = {\n      value,\n      selection: [from, to]\n    };\n    const unmaskedElementState = removeFixedMaskCharacters(initialElementState, maskExpression);\n    const [unmaskedFrom, unmaskedTo] = applyOverwriteMode(unmaskedElementState, newCharacters, this.maskOptions.overwriteMode).selection;\n    const newUnmaskedLeadingValuePart = unmaskedElementState.value.slice(0, unmaskedFrom) + newCharacters;\n    const newCaretIndex = newUnmaskedLeadingValuePart.length;\n    const maskedElementState = calibrateValueByMask({\n      value: newUnmaskedLeadingValuePart + unmaskedElementState.value.slice(unmaskedTo),\n      selection: [newCaretIndex, newCaretIndex]\n    }, maskExpression, initialElementState);\n    const isInvalidCharsInsertion = // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with\n    value.slice(0, unmaskedFrom) === calibrateValueByMask({\n      value: newUnmaskedLeadingValuePart,\n      selection: [newCaretIndex, newCaretIndex]\n    }, maskExpression, initialElementState).value;\n\n    if (isInvalidCharsInsertion || areElementStatesEqual(this, maskedElementState) // If typing new characters does not change value\n    ) {\n      throw new Error('Invalid mask value');\n    }\n\n    this.value = maskedElementState.value;\n    this.selection = maskedElementState.selection;\n  }\n\n  deleteCharacters([from, to]) {\n    if (from === to || !to) {\n      return;\n    }\n\n    const {\n      value\n    } = this;\n    const maskExpression = this.getMaskExpression({\n      value: value.slice(0, from) + value.slice(to),\n      selection: [from, from]\n    });\n    const initialElementState = {\n      value,\n      selection: [from, to]\n    };\n    const unmaskedElementState = removeFixedMaskCharacters(initialElementState, maskExpression);\n    const [unmaskedFrom, unmaskedTo] = unmaskedElementState.selection;\n    const newUnmaskedValue = unmaskedElementState.value.slice(0, unmaskedFrom) + unmaskedElementState.value.slice(unmaskedTo);\n    const maskedElementState = calibrateValueByMask({\n      value: newUnmaskedValue,\n      selection: [unmaskedFrom, unmaskedFrom]\n    }, maskExpression, initialElementState);\n    this.value = maskedElementState.value;\n    this.selection = maskedElementState.selection;\n  }\n\n  getMaskExpression(elementState) {\n    const {\n      mask\n    } = this.maskOptions;\n    return typeof mask === 'function' ? mask(elementState) : mask;\n  }\n\n}\n\nclass EventListener {\n  constructor(element) {\n    this.element = element;\n    this.listeners = [];\n  }\n\n  listen(eventType, fn, options) {\n    const untypedFn = fn;\n    this.element.addEventListener(eventType, untypedFn, options);\n    this.listeners.push(() => this.element.removeEventListener(eventType, untypedFn));\n  }\n\n  destroy() {\n    this.listeners.forEach(stopListen => stopListen());\n  }\n\n}\n\n/**\r\n * Checks if the passed keyboard event match the required hotkey.\r\n *\r\n * We intentionally use legacy {@link KeyboardEvent#keyCode `keyCode`} property. It is more\r\n * \"keyboard-layout\"-independent than {@link KeyboardEvent#key `key`} or {@link KeyboardEvent#code `code`} properties.\r\n *\r\n * @example\r\n * input.addEventListener('keydown', (event) => {\r\n *     if (isHotkey(event, HotkeyModifier.CTRL | HotkeyModifier.SHIFT, HotkeyCode.Z)) {\r\n *         // redo hotkey pressed\r\n *     }\r\n * })\r\n *\r\n * @see {@link https://github.com/taiga-family/maskito/issues/315 `KeyboardEvent#code` issue}\r\n *\r\n * @return will return `true` only if the {@link HotkeyCode} matches and only the necessary\r\n * {@link HotkeyModifier modifiers} have been pressed\r\n */\nfunction isHotkey(event, modifiers, hotkeyCode) {\n  return event.ctrlKey === !!(modifiers & 1\n  /* CTRL */\n  ) && event.altKey === !!(modifiers & 2\n  /* ALT */\n  ) && event.shiftKey === !!(modifiers & 4\n  /* SHIFT */\n  ) && event.metaKey === !!(modifiers & 8\n  /* META */\n  ) && event.keyCode === hotkeyCode;\n}\n\nfunction isRedo(event) {\n  return isHotkey(event, 1\n  /* CTRL */\n  , 89\n  /* Y */\n  ) || // Windows\n  isHotkey(event, 1\n  /* CTRL */\n  | 4\n  /* SHIFT */\n  , 90\n  /* Z */\n  ) || // Windows & Android\n  isHotkey(event, 8\n  /* META */\n  | 4\n  /* SHIFT */\n  , 90\n  /* Z */\n  ) // macOS & iOS\n  ;\n}\nfunction isUndo(event) {\n  return isHotkey(event, 1\n  /* CTRL */\n  , 90\n  /* Z */\n  ) || // Windows & Android\n  isHotkey(event, 8\n  /* META */\n  , 90\n  /* Z */\n  ) // macOS & iOS\n  ;\n}\n\n/**\r\n * \"beforeinput\" is more appropriate event for preprocessing of the input masking (than `keydown`):\r\n * - `keydown` is not triggered by predictive text from native mobile keyboards.\r\n * - `keydown` is triggered by system key combinations (we don't need them, and they should be manually filtered).\r\n * - Dropping text inside input triggers `beforeinput` (but not `keydown`).\r\n * ___\r\n * \"beforeinput\" is not supported by Chrome 49+ (only from 60+) and by Firefox 52+ (only from 87+).\r\n *\r\n * @see https://caniuse.com/?search=beforeinput\r\n * @see https://taiga-ui.dev/browser-support\r\n */\nfunction isBeforeInputEventSupported(element) {\n  return 'onbeforeinput' in element;\n}\n\nfunction isEventProducingCharacter({\n  key,\n  ctrlKey,\n  metaKey,\n  altKey\n}) {\n  const isSystemKeyCombinations = ctrlKey || metaKey || altKey;\n  const isSingleUnicodeChar = /^.$/u.test(key); // 4-byte characters case (e.g. smile)\n\n  return !isSystemKeyCombinations && key !== 'Backspace' && isSingleUnicodeChar;\n}\n\nfunction getLineSelection({\n  value,\n  selection\n}, isForward) {\n  const [from, to] = selection;\n\n  if (from !== to) {\n    return [from, to];\n  }\n\n  const nearestBreak = isForward ? value.slice(from).indexOf('\\n') + 1 || value.length : value.slice(0, to).lastIndexOf('\\n') + 1;\n  const selectFrom = isForward ? from : nearestBreak;\n  const selectTo = isForward ? nearestBreak : to;\n  return [selectFrom, selectTo];\n}\n\nfunction getNotEmptySelection({\n  value,\n  selection\n}, isForward) {\n  const [from, to] = selection;\n\n  if (from !== to) {\n    return [from, to];\n  }\n\n  const notEmptySelection = isForward ? [from, to + 1] : [from - 1, to];\n  return notEmptySelection.map(x => Math.min(Math.max(x, 0), value.length));\n}\n\nconst TRAILING_SPACES_REG = /\\s+$/g;\nconst LEADING_SPACES_REG = /^\\s+/g;\nconst SPACE_REG = /\\s/;\nfunction getWordSelection({\n  value,\n  selection\n}, isForward) {\n  const [from, to] = selection;\n\n  if (from !== to) {\n    return [from, to];\n  }\n\n  if (isForward) {\n    const valueAfterSelectionStart = value.slice(from);\n    const [leadingSpaces] = valueAfterSelectionStart.match(LEADING_SPACES_REG) || [''];\n    const nearestWordEndIndex = valueAfterSelectionStart.replace(LEADING_SPACES_REG, '') // TODO replace with `String.trimStart` after bumping Firefox to 61+\n    .search(SPACE_REG);\n    return [from, nearestWordEndIndex !== -1 ? from + leadingSpaces.length + nearestWordEndIndex : value.length];\n  }\n\n  const valueBeforeSelectionEnd = value.slice(0, to);\n  const [trailingSpaces] = valueBeforeSelectionEnd.match(TRAILING_SPACES_REG) || [''];\n  const selectedWordLength = valueBeforeSelectionEnd.replace(TRAILING_SPACES_REG, '') // TODO replace with `String.trimEnd` after bumping Firefox to 61+\n  .split('').reverse().findIndex(char => char.match(SPACE_REG));\n  return [selectedWordLength !== -1 ? to - trailingSpaces.length - selectedWordLength : 0, to];\n}\n\n/* eslint-disable @typescript-eslint/ban-types */\n\n/**\r\n * @internal\r\n */\nfunction maskitoPipe(processors = []) {\n  return (initialData, ...readonlyArgs) => processors.reduce((data, fn) => Object.assign(Object.assign({}, data), fn(data, ...readonlyArgs)), initialData);\n}\n\nfunction maskitoTransform(valueOrState, maskitoOptions) {\n  const options = Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), maskitoOptions);\n  const preprocessor = maskitoPipe(options.preprocessors);\n  const postprocessor = maskitoPipe(options.postprocessors);\n  const initialElementState = typeof valueOrState === 'string' ? {\n    value: valueOrState,\n    selection: [0, 0]\n  } : valueOrState;\n  const {\n    elementState\n  } = preprocessor({\n    elementState: initialElementState,\n    data: ''\n  }, 'validation');\n  const maskModel = new MaskModel(elementState, options);\n  const {\n    value,\n    selection\n  } = postprocessor(maskModel, initialElementState);\n  return typeof valueOrState === 'string' ? value : {\n    value,\n    selection\n  };\n}\n\nclass Maskito extends MaskHistory {\n  constructor(element, maskitoOptions) {\n    super();\n    this.element = element;\n    this.maskitoOptions = maskitoOptions;\n    this.isTextArea = this.element.nodeName === 'TEXTAREA';\n    this.eventListener = new EventListener(this.element);\n    this.options = Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), this.maskitoOptions);\n    this.preprocessor = maskitoPipe(this.options.preprocessors);\n    this.postprocessor = maskitoPipe(this.options.postprocessors);\n    this.teardowns = this.options.plugins.map(plugin => plugin(this.element, this.options));\n    this.ensureValueFitsMask();\n    this.updateHistory(this.elementState);\n    this.eventListener.listen('keydown', event => {\n      if (isRedo(event)) {\n        event.preventDefault();\n        return this.redo();\n      }\n\n      if (isUndo(event)) {\n        event.preventDefault();\n        return this.undo();\n      }\n    });\n\n    if (isBeforeInputEventSupported(element)) {\n      this.eventListener.listen('beforeinput', event => {\n        const isForward = event.inputType.includes('Forward');\n        this.updateHistory(this.elementState);\n\n        switch (event.inputType) {\n          // historyUndo/historyRedo will not be triggered if value was modified programmatically\n          case 'historyUndo':\n            event.preventDefault();\n            return this.undo();\n\n          case 'historyRedo':\n            event.preventDefault();\n            return this.redo();\n\n          case 'deleteByCut':\n          case 'deleteContentBackward':\n          case 'deleteContentForward':\n            return this.handleDelete({\n              event,\n              isForward,\n              selection: getNotEmptySelection(this.elementState, isForward)\n            });\n\n          case 'deleteWordForward':\n          case 'deleteWordBackward':\n            return this.handleDelete({\n              event,\n              isForward,\n              selection: getWordSelection(this.elementState, isForward),\n              force: true\n            });\n\n          case 'deleteSoftLineBackward':\n          case 'deleteSoftLineForward':\n          case 'deleteHardLineBackward':\n          case 'deleteHardLineForward':\n            return this.handleDelete({\n              event,\n              isForward,\n              selection: getLineSelection(this.elementState, isForward),\n              force: true\n            });\n\n          case 'insertCompositionText':\n            return;\n          // will be handled inside `compositionend` event\n\n          case 'insertLineBreak':\n            return this.handleEnter(event);\n\n          case 'insertFromPaste':\n          case 'insertText':\n          case 'insertFromDrop':\n          default:\n            return this.handleInsert(event, event.data || '');\n        }\n      });\n    } else {\n      /** TODO: drop it after browser support bump (Firefox 87+)\r\n       * Also, replace union types `Event | TypedInputEvent` with `TypedInputEvent` inside:\r\n       *** {@link handleDelete}\r\n       *** {@link handleInsert}\r\n       */\n      this.eventListener.listen('keydown', event => this.handleKeydown(event));\n      this.eventListener.listen('paste', event => {\n        var _a;\n\n        return this.handleInsert(event, ((_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text/plain')) || '');\n      });\n    }\n\n    this.eventListener.listen('input', ({\n      inputType\n    }) => {\n      if (inputType === 'insertCompositionText') {\n        return; // will be handled inside `compositionend` event\n      }\n\n      this.ensureValueFitsMask();\n      this.updateHistory(this.elementState);\n    });\n    this.eventListener.listen('compositionend', () => {\n      this.ensureValueFitsMask();\n      this.updateHistory(this.elementState);\n    });\n  }\n\n  get elementState() {\n    const {\n      value,\n      selectionStart,\n      selectionEnd\n    } = this.element;\n    return {\n      value,\n      selection: [selectionStart || 0, selectionEnd || 0]\n    };\n  }\n\n  get maxLength() {\n    const {\n      maxLength\n    } = this.element;\n    return maxLength === -1 ? Infinity : maxLength;\n  }\n\n  destroy() {\n    this.eventListener.destroy();\n    this.teardowns.forEach(teardown => teardown === null || teardown === void 0 ? void 0 : teardown());\n  }\n\n  updateElementState({\n    value,\n    selection\n  }, eventInit = {\n    inputType: 'insertText',\n    data: null\n  }) {\n    const initialValue = this.elementState.value;\n    this.updateValue(value);\n    this.updateSelectionRange(selection);\n\n    if (initialValue !== value) {\n      this.dispatchInputEvent(eventInit);\n    }\n  }\n\n  updateSelectionRange([from, to]) {\n    var _a, _b;\n\n    if (this.element.selectionStart !== from || this.element.selectionEnd !== to) {\n      (_b = (_a = this.element).setSelectionRange) === null || _b === void 0 ? void 0 : _b.call(_a, from, to);\n    }\n  }\n\n  updateValue(value) {\n    this.element.value = value;\n  }\n\n  ensureValueFitsMask() {\n    this.updateElementState(maskitoTransform(this.elementState, this.options));\n  }\n\n  dispatchInputEvent(eventInit = {\n    inputType: 'insertText',\n    data: null\n  }) {\n    const globalObject = typeof window !== 'undefined' ? window : globalThis; // TODO: replace `globalObject` with `globalThis` after bumping Firefox to 65+\n    // @see https://caniuse.com/?search=globalThis\n\n    if (globalObject === null || globalObject === void 0 ? void 0 : globalObject.InputEvent) {\n      this.element.dispatchEvent(new InputEvent('input', Object.assign(Object.assign({}, eventInit), {\n        bubbles: true,\n        cancelable: false\n      })));\n    }\n  }\n\n  handleKeydown(event) {\n    const pressedKey = event.key;\n    const isForward = pressedKey === 'Delete';\n\n    switch (pressedKey) {\n      case 'Backspace':\n      case 'Delete':\n        return this.handleDelete({\n          event,\n          isForward,\n          selection: getNotEmptySelection(this.elementState, isForward)\n        });\n\n      case 'Enter':\n        return this.handleEnter(event);\n    }\n\n    if (!isEventProducingCharacter(event)) {\n      return;\n    }\n\n    this.handleInsert(event, pressedKey);\n  }\n\n  handleDelete({\n    event,\n    selection,\n    isForward,\n    force = false\n  }) {\n    const initialState = {\n      value: this.elementState.value,\n      selection\n    };\n    const [initialFrom, initialTo] = initialState.selection;\n    const {\n      elementState\n    } = this.preprocessor({\n      elementState: initialState,\n      data: ''\n    }, isForward ? 'deleteForward' : 'deleteBackward');\n    const maskModel = new MaskModel(elementState, this.options);\n    const [from, to] = elementState.selection;\n    maskModel.deleteCharacters([from, to]);\n    const newElementState = this.postprocessor(maskModel, initialState);\n    const newPossibleValue = initialState.value.slice(0, initialFrom) + initialState.value.slice(initialTo);\n\n    if (newPossibleValue === newElementState.value && !force) {\n      return;\n    }\n\n    event.preventDefault();\n\n    if (areElementValuesEqual(initialState, elementState, maskModel, newElementState)) {\n      // User presses Backspace/Delete for the fixed value\n      return this.updateSelectionRange(isForward ? [to, to] : [from, from]);\n    } // TODO: drop it when `event: Event | TypedInputEvent` => `event: TypedInputEvent`\n\n\n    const inputTypeFallback = isForward ? 'deleteContentForward' : 'deleteContentBackward';\n    this.updateElementState(newElementState, {\n      inputType: 'inputType' in event ? event.inputType : inputTypeFallback,\n      data: null\n    });\n    this.updateHistory(newElementState);\n  }\n\n  handleInsert(event, data) {\n    const initialElementState = this.elementState;\n    const {\n      elementState,\n      data: insertedText = data\n    } = this.preprocessor({\n      data,\n      elementState: initialElementState\n    }, 'insert');\n    const maskModel = new MaskModel(elementState, this.options);\n\n    try {\n      maskModel.addCharacters(elementState.selection, insertedText);\n    } catch (_a) {\n      return event.preventDefault();\n    }\n\n    const [from, to] = elementState.selection;\n    const newPossibleValue = elementState.value.slice(0, from) + data + elementState.value.slice(to);\n    const newElementState = this.postprocessor(maskModel, initialElementState);\n\n    if (newElementState.value.length > this.maxLength) {\n      return event.preventDefault();\n    }\n\n    if (newPossibleValue !== newElementState.value) {\n      event.preventDefault();\n      this.updateElementState(newElementState, {\n        data,\n        inputType: 'inputType' in event ? event.inputType : 'insertText'\n      });\n      this.updateHistory(newElementState);\n    }\n  }\n\n  handleEnter(event) {\n    if (this.isTextArea) {\n      this.handleInsert(event, '\\n');\n    }\n  }\n\n}\n\nexport { MASKITO_DEFAULT_ELEMENT_PREDICATE, MASKITO_DEFAULT_OPTIONS, Maskito, maskitoPipe, maskitoTransform };\n", "import { Maskito, MASKITO_DEFAULT_OPTIONS, MASKITO_DEFAULT_ELEMENT_PREDICATE } from '@maskito/core';\nimport { useLayoutEffect, useEffect, useState, useCallback, useRef } from 'react';\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n\nfunction isThenable(x) {\n  return x && typeof x === 'object' && 'then' in x;\n}\n/**\r\n * Hook for convenient use of Maskito in React\r\n * @description For controlled inputs use `onInput` event\r\n * @param options options used for creating Maskito\r\n * @param elementPredicate function that can help find nested Input or TextArea\r\n * @returns ref callback to pass it in React Element\r\n * @example\r\n * // To avoid unnecessary hook runs with Maskito recreation pass named variables\r\n * // good example ✅\r\n * useMaskito({ options: maskitoOptions, elementPredicate: maskitoPredicate })\r\n *\r\n * // bad example ❌\r\n * useMaskito({ options: { mask: /^.*$/ }, elementPredicate: () => e.querySelector('input') })\r\n */\n\n\nconst useMaskito = ({\n  options = MASKITO_DEFAULT_OPTIONS,\n  elementPredicate = MASKITO_DEFAULT_ELEMENT_PREDICATE\n} = {}) => {\n  const [hostElement, setHostElement] = useState(null);\n  const [element, setElement] = useState(null);\n  const onRefChange = useCallback(node => {\n    setHostElement(node);\n  }, []);\n  const latestPredicateRef = useRef(elementPredicate);\n  latestPredicateRef.current = elementPredicate;\n  useIsomorphicLayoutEffect(() => {\n    if (!hostElement) {\n      return;\n    }\n\n    const predicate = elementPredicate;\n    const elementOrPromise = predicate(hostElement);\n\n    if (isThenable(elementOrPromise)) {\n      void elementOrPromise.then(el => {\n        if (latestPredicateRef.current === predicate) {\n          setElement(el);\n        }\n      });\n    } else {\n      setElement(elementOrPromise);\n    }\n  }, [hostElement, elementPredicate, latestPredicateRef]);\n  useIsomorphicLayoutEffect(() => {\n    if (!element) {\n      return;\n    }\n\n    const maskedElement = new Maskito(element, options);\n    return () => {\n      maskedElement.destroy();\n    };\n  }, [options, element]);\n  return onRefChange;\n};\n\nexport { useMaskito };\n"],
  "mappings": "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",
  "names": []
}
